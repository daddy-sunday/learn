
raft 写
leader 写流程
	1。请求数据被leader 收到
	2.消息写入 存储log队列，发送消息队列，应用log队列（不提交的log不会被应用）
	3.等待保存log结果
	4.响应客户端消息

follower 收到leader流程：
	1.raft消息验证
	2.验证通过 保存消息到 存储log队列
	3.成功  将消息写入 应用队列，并响应客户端消息

三个异步线程：
	存储log线程，发送消息线程，应用log线程。
异步线程优点：都是批量操作，可以提升写入速度。


raft leader漂移
	leader 停止对外提供的写服务，可以正常读取数据。
	leader 检查 longIndex  等于 appliedIndex 等于 继位leader appliedIndex
	leader 退位，并通知继位leader 上位

未实现的功能：
使用rocksDB的snapshaot能力，实现添加节点或故障转移时快速恢复log entires的功能，还可以实现定期清理日志条目（只保留最近的或者小于多少的long entries），减少存储空间的占用。
  实现逻辑：
    leader 通过rockDB 提供的快照功能，获取rockDB快照。
    leader 通过快照读获取当前所有应用数据和appliedIndexId，并通过rockDB提供的writeSstFile能力将数据保存为sst文件。
    将sst文件发送到需要恢复数据的节点，完成后，在同步当前快照对应的log数据。
    这里不对sst文件进行存储。没有必要。只是借助快照的能力

raft 配置变更
	定义配置变更类型，
	当addRequest的数据类型为配置变更类型时，应用log中的成员信息到配置中

	流程：
	  发送新的配置变更消息给leader ，leader 将消息转化为 共识消息（新配置加老配置）（并立即应用共识配置）。然后将这条信息封装成log entries 走raft流程。
	  等待新添加节点日志追赶上来（新添加节点不参加选举也不算大多数)，然后leader 将新配置封装成 log entries 走一遍raft流程。当被应用时
	  判断自己还在不在成员列表中，如果不在就转变为等待退出状态。leader也转变为空闲状态

  支持的成员变更类型：
	  减少成员
	  添加成员
	  支持选择添加成员类型。（学习者或者是跟随者，并支持这两种类型之间相互切换）

事务：
事务类型：
	写入一条特殊的key
	客户端在创建时生成唯一标识id ，调用开启事务方法（传入唯一标识id） ，返回事务id
	在每次写入、更新、查询操作时隐式的带上事务id。
	客户端通过业务逻辑判断要提交事务还是回滚事务。


消息隐藏字段：状态 、事务id

	leader节点收到开启事务方法：
		生成事务专属的key消息 。
		  内容： 特殊的key，客户端id， 事务id，开启事务标识，
		同步消息成功后再内存中维护一个事物管理数据结构 事务id，客户端id ，状态
		最后返回事务id。
   leader节点收到提交事务方法：
         发送同步消息，内容为修改事务状态为提交状态；成功后执行
            删除所有事务id相关数据 。
   leader节点收到回滚事务方法：
         发送同步消息，内容为修改事务状态为提交状态；成功后执行

   leader节点启动后搜索事务表，检查没有提交的事务判断定为回滚事务。
    将这些事务对应的数据清理掉。

    数据记录
        删除一条记录操作：
           向记录中插入一条数据， key ： deleteFlag（true），事务id
        update操作：
           向记录中插入-条数据， key：deleteFlag（false），事务id ，更新值
        添加操作：
           向记录中插入-条数据， key：deleteFlag（false），事务id ，新值

    事务记录数据结构描述：（目前的理解：对清理有用，其它的没用。这个可以先不做）
      特殊key_事务id_自增id ，添加的key
      特殊key_事务id_自增id ，删除的key

    事务状态管理表：
    特殊key_事务id , 状态

垃圾数据清理:
  被回滚的事务数据：
  事务已经提交的被删除数据：
  mvcc原理产生的历史拉链数据：

锁数据记录在内存中，由leader管理
    锁管理：
      读锁：
        读取数据时不加锁 ，通过mvcc实现
      写锁：
        客户端：写入数据时，先向leader请求锁。 请求成功后写入数据，请求失败经过重试后依然失败的则写入终止。
        服务端：收到写入请求后，通过key申请锁，申请成功写入log，经过重试策略失败后终止写入。
      数据记录锁类型：
             范围锁
                 指定行->最后一行
                 第一行->指定行
                 指定行->指定行
             单行锁
                 指定行

读取逻辑变更：
    通过key 值可能会找到多行记录。这些记录通过事务id排序后，找到事务id最大的已经交未删除记录时返回。（小于返回事务id的数据都是垃圾数据，可以清除）

空闲时间无效事务数据处理：
    遍历所有数据，过滤出失败事务需要回滚的数据清理掉。并清理事务记录。
    删除已经失效的事务记录。应该是有一个事务id标识，这个事务id之前事务已经没有存在意义了。


multi raft实现：
  每次遍历：
      一起发送心跳
  接收到的raft消息统一放入队列中
      每100毫秒处理一次
  每个raft单独应用自己的


来数据了 ，放入队列 ，

100秒后处理队列内数据 。
  将队列内数据分组使用多线程执行。
  完成后将结果写入应用队列。返回结果log结




表id_rowId_shiwuId


